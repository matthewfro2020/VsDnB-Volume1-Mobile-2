package
; graphics
; import flixel.FlxSprite;
;
; import flixel.FlxG;
;
; import flixel.animation.FlxAnimationController;
;
; import flixel.graphics.frames.FlxAtlasFrames;
;
; import flixel.util.FlxSignal.FlxTypedSignal;
;
; /** * Replacement for flxanimate-based FlxAtlasSprite. * Uses FlxSprite + FlxAtlasFrames ONLY.
*/ class FlxAtlasSprite extends FlxSprite
{ /** Signal fired when animation starts.
*/ public var onStart:FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>()
; /** Path used for atlas loading (optional).
*/ public var atlasPath:String = ""
; public function new(x:Float = 0, y:Float = 0, ?path:String)
{ super(x, y)
; if (path != null) loadAtlas(path)
; } /** * Load a Sparrow / Atlas folder generated by your exporter. * Expects: * atlas.png * atlas.xml
*/ public function loadAtlas(path:String)
{ atlasPath = path
; var frames:FlxAtlasFrames = FlxAtlasFrames.fromSparrow('$
{ path
} .png', '$
{ path
} .xml')
; if (frames == null)
{ FlxG.log.error('Atlas load failed at path: $path')
; return
; } this.frames = frames
; this.animation = new FlxAnimationController(this)
; // Default animation if any prefix exists
// Default animation if any prefix exists if (frames.frames.length > 0)
{ var first = frames.frames[0].name
; var prefix = getPrefix(first)
; if (prefix == "") prefix = first
; // optional but safer
// FIX: specify postfix explicitly to avoid overload conflict this.animation.addByPrefix("idle", prefix, 24, true)
; }
} /** * Extracts the prefix of a frame name by removing trailing numbers. * Example: * "idle0000" -> "idle" * "walk_left_01" -> "walk_left_" * "attack3" -> "attack"
*/ function getPrefix(name:String):String
{ var i = name.length - 1
; while (i >= 0)
{ var c = name.charAt(i)
; if (c >= "0" && c <= "9") i--
; else break
; } return name.substr(0, i + 1)
; } /** * Adds animation by prefix (default FNF style).
*/ public function addByPrefix(name:String, prefix:String, frameRate:Int = 24, loop:Bool = true)
{ this.animation.addByPrefix(name, prefix, frameRate, loop)
; } /** * Adds animation by manual indices.
*/ public function addByIndices(name:String, prefix:String, indices:Array<Int>, frameRate:Int = 24, loop:Bool = true)
{ this.animation.addByIndices(name, prefix, indices, "", frameRate, loop, false, false)
; } /** * Remove animation.
*/ public function remove(name:String):Bool
{ return animation._animations.remove(name)
; } /** * Play animation.
*/ public function playAnimation(name:String, force:Bool = false, reversed:Bool = false, startFrame:Int = 0)
{ if (!animation.exists(name))
{ FlxG.log.warn('Animation "$name" does not exist.')
; return
; } animation.play(name, force, reversed, startFrame)
; onStart.dispatch(name)
; } /** * Pause.
*/ public function pause()
{ animation.pause()
; } /** * Resume.
*/ public function resume()
{ animation.resume()
; } /** * List of animation names.
*/ public var animations(get, null):Array<String>
; function get_animations():Array<String>
{ return animation.getAnimationList()
; } /** * Current animation name.
*/ public var curAnimName(get, null):String
; function get_curAnimName():String
{ return animation.curAnim != null ? animation.curAnim.name : ""
; } /** * Whether animation exists.
*/ public inline function animationExists(name:String):Bool
{ return animation.exists(name)
; }
}
